# Compiladores - Trabalho Pr√°tico 1

## üìã √çndice
- [Descri√ß√£o do Projeto](#-descri√ß√£o-do-projeto)
- [Estrutura do Projeto](#-estrutura-do-projeto)
- [Como Executar](#-como-executar)
- [Explica√ß√£o Detalhada do C√≥digo](#-explica√ß√£o-detalhada-do-c√≥digo)
- [Exemplos de Uso](#-exemplos-de-uso)
- [Gram√°tica da Linguagem](#-gram√°tica-da-linguagem)
- [Detalhes de Implementa√ß√£o](#-detalhes-de-implementa√ß√£o)

## üéØ Descri√ß√£o do Projeto

Este projeto implementa um **compilador b√°sico** para um subconjunto da linguagem de programa√ß√£o Ada. O compilador √© dividido em duas fases principais:

1. **An√°lise L√©xica (Scanner)**: Converte o c√≥digo fonte em uma sequ√™ncia de tokens
2. **An√°lise Sint√°tica (Parser)**: Constr√≥i uma Abstract Syntax Tree (AST) a partir dos tokens

### üé® Caracter√≠sticas da Linguagem Implementada

#### Estrutura B√°sica
```ada
procedure Main is
begin
    -- comandos aqui
end;
```

#### Express√µes Suportadas
- **Aritm√©ticas**: `+`, `-`, `*`, `/`
- **Booleanas**: `and`, `or`, `not`, `=`, `<`, `>`
- **Fun√ß√µes de E/S**: `Put_Line()`, `Get_Line()`

#### Comandos Suportados
- **Atribui√ß√µes**: `vari√°vel := express√£o;`
- **Condicionais**: `if then else end if;`
- **Loops**: `while loop end loop;`

## üìÅ Estrutura do Projeto

```
COMP_TP1_GRUPO_X/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ AST.hs          # Defini√ß√µes dos n√≥s da AST
‚îÇ   ‚îú‚îÄ‚îÄ Lexer.hs        # Analisador L√©xico
‚îÇ   ‚îú‚îÄ‚îÄ Parser.hs       # Analisador Sint√°tico
‚îÇ   ‚îî‚îÄ‚îÄ Main.hs         # Programa principal
‚îú‚îÄ‚îÄ examples/
‚îÇ   ‚îú‚îÄ‚îÄ test1.ada       # Exemplo com c√°lculos e if
‚îÇ   ‚îú‚îÄ‚îÄ test2.ada       # Exemplo com while loop
‚îÇ   ‚îî‚îÄ‚îÄ test3.ada       # Exemplo com express√µes booleanas
‚îú‚îÄ‚îÄ stack.yaml          # Configura√ß√£o do Stack
‚îî‚îÄ‚îÄ COMP_TP1_GRUPO_X.cabal  # Configura√ß√£o do projeto Cabal
```

## üöÄ Como Executar

### Pr√©-requisitos
- [Stack](https://haskellstack.org/) instalado

### Comandos

```bash
# Compilar o projeto
stack build

# Executar com um arquivo de exemplo
stack run examples/test1.ada

# Executar no GHCi (para desenvolvimento)
stack ghci
> :main examples/test1.ada

# Executar todos os testes
stack run
```

## üîç Explica√ß√£o Detalhada do C√≥digo

### 1. **AST.hs - Abstract Syntax Tree**

Este arquivo define a estrutura de dados que representa o programa ap√≥s a an√°lise sint√°tica.

```haskell
-- Um programa Ada √© uma procedure com nome e lista de statements
data Program = Program String [Statement]

-- Tipos de statements (comandos) suportados
data Statement 
    = Assignment String Expression    -- x := 10;
    | If Expression [Statement] (Maybe [Statement])  -- if then else
    | While Expression [Statement]    -- while loop
    | ExpressionStmt Expression       -- Put_Line("hello");

-- Tipos de express√µes suportadas
data Expression
    = Var String                      -- vari√°vel: x
    | IntLit Integer                  -- n√∫mero: 42
    | StrLit String                   -- string: "hello"
    | BinOp Op Expression Expression  -- opera√ß√£o bin√°ria: x + y
    | UnOp UnOp Expression            -- opera√ß√£o un√°ria: not flag
    | Call String [Expression]        -- chamada de fun√ß√£o: Put_Line("hi")

-- Operadores bin√°rios
data Op = Add | Sub | Mul | Div | Eq | Lt | Gt | And | Or

-- Operadores un√°rios  
data UnOp = Not | Neg
```

**Exemplo**: O c√≥digo `x := 10 + 5;` vira:
```haskell
Assignment "x" (BinOp Add (IntLit 10) (IntLit 5))
```

### 2. **Lexer.hs - Analisador L√©xico**

O lexer converte o c√≥digo fonte em tokens (unidades l√©xicas).

#### Como funciona:

1. **L√™ caractere por caractere** do c√≥digo fonte
2. **Agrupa caracteres** para formar tokens
3. **Classifica cada token** (identificador, n√∫mero, operador, etc.)

```haskell
-- Tipos de tokens reconhecidos
data Token
    = TIdentifier String    -- nomes de vari√°veis/fun√ß√µes
    | TInt Integer          -- n√∫meros inteiros
    | TString String        -- strings entre aspas
    | TProcedure           -- palavra-chave 'procedure'
    | TAssign              -- operador ':='
    | TPlus                -- operador '+'
    -- ... outros tokens
```

#### Processo de An√°lise L√©xica:

```haskell
lexer "x := 10 + 5;"
-- ‚Üì Converte para:
[TIdentifier "x", TAssign, TInt 10, TPlus, TInt 5, TSemi]
```

**Detalhes importantes:**
- Ignora espa√ßos em branco e coment√°rios
- Reconhece palavras reservadas (`if`, `while`, `procedure`)
- Diferencia identificadores de palavras-chave
- Mant√©m informa√ß√£o de linha/coluna para mensagens de erro

### 3. **Parser.hs - Analisador Sint√°tico**

O parser transforma a lista de tokens em uma AST usando parser combinators.

#### Estrat√©gia: Parser Recursivo Descendente

```haskell
-- Tipo do parser: pode retornar um valor ou erro, mant√©m estado dos tokens
type Parser = ExceptT String (State [Token])

-- Fun√ß√µes principais do parser:
parseProgram   :: Parser Program      -- Programa completo
parseStatement :: Parser Statement    -- Um comando
parseExpression :: Parser Expression  -- Uma express√£o
```

#### Hierarquia de Parsing:

```
parseProgram
  ‚Üì
parseProcedure
  ‚Üì  
parseStatements
  ‚Üì
parseStatement ‚Üí parseAssignment | parseIf | parseWhile | parseExpression
  ‚Üì
parseExpression ‚Üí parseOr ‚Üí parseAnd ‚Üí parseComparison ‚Üí parseTerm ‚Üí parseFactor ‚Üí parsePrimary
```

#### Exemplo de Parsing:

```ada
-- C√≥digo fonte:
x := 10 + 5;

-- Tokens:
[TIdentifier "x", TAssign, TInt 10, TPlus, TInt 5, TSemi]

-- Processo:
1. parseStatement v√™ TIdentifier + TAssign ‚Üí parseAssignment
2. parseAssignment:
   - Consome TIdentifier "x"
   - Consome TAssign
   - Chama parseExpression para "10 + 5"
   - parseExpression constr√≥i: BinOp Add (IntLit 10) (IntLit 5)
   - Consome TSemi
3. Retorna: Assignment "x" (BinOp Add (IntLit 10) (IntLit 5))
```

### 4. **Main.hs - Programa Principal**

Orquestra todo o processo de compila√ß√£o:

```haskell
main :: IO ()
main = do
    -- 1. L√™ arquivo de entrada
    content <- readFile "exemplo.ada"
    
    -- 2. An√°lise l√©xica
    let tokens = lexer content
    
    -- 3. An√°lise sint√°tica  
    case parse tokens of
        Left err -> putStrLn $ "Erro: " ++ err
        Right ast -> print ast
```

## üìù Exemplos de Uso

### Exemplo 1: C√°lculos e Condicionais
```ada
-- examples/test1.ada
procedure Main is
begin
    x := 10;
    y := x + 5 * 2;
    
    if x > 5 then
        Put_Line("x is greater than 5");
    else
        Put_Line("x is 5 or less");
    end if;
end;
```

**Sa√≠da do Compilador:**
```
=== TOKENS ===
TProcedure
TIdentifier "Main"
TIs
TBegin
TIdentifier "x"
TAssign
TInt 10
TSemi
...

=== AST ===
Program "Main" [
    Assignment "x" (IntLit 10),
    Assignment "y" (BinOp Add (Var "x") (BinOp Mul (IntLit 5) (IntLit 2))),
    If (BinOp Gt (Var "x") (IntLit 5)) [
        ExpressionStmt (Call "Put_Line" [StrLit "x is greater than 5"])
    ] (Just [
        ExpressionStmt (Call "Put_Line" [StrLit "x is 5 or less"])
    ])
]
```

### Exemplo 2: Loop While
```ada
procedure Main is
begin
    counter := 5;
    
    while counter > 0 loop
        Put_Line("Counting down");
        counter := counter - 1;
    end loop;
end;
```

### Exemplo 3: Express√µes Booleanas Complexas
```ada
procedure Main is
begin
    age := 25;
    
    if age >= 18 and age < 65 then
        Put_Line("Adult of working age");
    else
        Put_Line("Not in working age group");
    end if;
end;
```

## üìñ Gram√°tica da Linguagem

```
Program     ‚Üí "procedure" Identifier "is" "begin" Statements "end" ";"

Statements  ‚Üí Statement*
Statement   ‚Üí Assignment | IfStatement | WhileStatement | ExpressionStatement

Assignment  ‚Üí Identifier ":=" Expression ";"
IfStatement ‚Üí "if" Expression "then" Statements ["else" Statements] "end" "if" ";"
WhileStatement ‚Üí "while" Expression "loop" Statements "end" "loop" ";"
ExpressionStatement ‚Üí Expression ";"

Expression  ‚Üí OrExpression
OrExpression ‚Üí AndExpression ("or" AndExpression)*
AndExpression ‚Üí Comparison ("and" Comparison)*
Comparison  ‚Üí Term (("=" | "<" | ">") Term)*
Term        ‚Üí Factor (("+" | "-") Factor)*
Factor      ‚Üí Primary (("*" | "/") Primary)*
Primary     ‚Üí Integer | String | Identifier | FunctionCall | "(" Expression ")"
FunctionCall ‚Üí Identifier "(" [Arguments] ")"
Arguments   ‚Üí Expression ("," Expression)*
```

## ‚öôÔ∏è Detalhes de Implementa√ß√£o

### üß© Parser Combinators

Usamos uma abordagem mon√°dica para parsing:

```haskell
-- Combinador b√°sico: consome um token esperado
match :: Token -> Parser Token
match expected = do
    tokens <- get
    case tokens of
        (token:rest) | token == expected -> put rest >> return token
        _ -> throwError $ "Expected " ++ show expected

-- Combinador para identificadores
matchIdentifier :: Parser String
matchIdentifier = do
    tokens <- get
    case tokens of
        (TIdentifier name:rest) -> put rest >> return name
        _ -> throwError "Expected identifier"
```

### üé≠ Pattern Matching

Haskell brilha no pattern matching para an√°lise sint√°tica:

```haskell
parseStatement :: Parser Statement
parseStatement = do
    tokens <- get
    case tokens of
        (TIf:_) -> parseIf                    -- Come√ßa com 'if'? ‚Üí parseIf
        (TWhile:_) -> parseWhile              -- Come√ßa com 'while'? ‚Üí parseWhile  
        (TIdentifier _:TAssign:_) -> parseAssignment  -- Ident + := ‚Üí atribui√ß√£o
        _ -> ExpressionStmt <$> parseExpression  -- Sen√£o ‚Üí express√£o
```

### üîÑ Recurs√£o e Composi√ß√£o

As express√µes s√£o analisadas recursivamente:

```haskell
parseExpression = parseOr
parseOr = do
    left <- parseAnd
    parseOr' left
  where
    parseOr' left = do
        tokens <- get
        case tokens of
            (TOr:rest) -> do
                put rest
                right <- parseAnd
                parseOr' (BinOp Or left right)
            _ -> return left
```

## üéØ Caracter√≠sticas do Haskell Aproveitadas

1. **Tipos Alg√©bricos**: Perfectos para representar ASTs
2. **Pattern Matching**: Ideal para an√°lise de tokens
3. **Recurs√£o**: Natural para parsers recursivos
4. **Monads**: Para composi√ß√£o de parsers com estado
5. **Imutabilidade**: Elimina bugs de estado compartilhado

## ‚ö†Ô∏è Limita√ß√µes Atuais

1. **N√£o verifica tipos** em tempo de compila√ß√£o
2. **Sem an√°lise sem√¢ntica** (vari√°veis n√£o declaradas, etc.)
3. **Tratamento de erros b√°sico**
4. **N√£o gera c√≥digo** - apenas an√°lise

